"""PostgreSQL Class module

An opinionated wrapper for interfacing with PostgreSQL that offers caching of
connections and support for PyPy via psycopg2ct. By default the PgSQL class
sets the cursor type to extras.DictCursor, and turns on both Unicode and UUID
support.

"""
__version__ = '1.1.2'

import hashlib
import logging
import platform
import time

# Import PyPy compatibility
PYPY = False
target = platform.python_implementation()
if target == 'PyPy':
    from psycopg2ct import compat
    compat.register()
    PYPY = True

# Import psycopg2 and it's extensions and extras
import psycopg2
from psycopg2 import extensions
from psycopg2 import extras

# Expose exceptions so clients do not need to import psycopg2 too
from psycopg2 import DataError
from psycopg2 import DatabaseError
from psycopg2 import IntegrityError
from psycopg2 import InterfaceError
from psycopg2 import InternalError
from psycopg2 import NotSupportedError
from psycopg2 import OperationalError
from psycopg2 import ProgrammingError
from psycopg2.extensions import QueryCanceledError
from psycopg2.extensions import TransactionRollbackError

LOGGER = logging.getLogger(__name__)

# Empty connection TTL
CACHE_TTL = 60
CLIENTS = 'clients'
HANDLE = 'handle'
LAST = 'last_client'
CONNECTIONS = dict()


def _add_cached_connection(dsn_hash, connection):
    """Add the connection to our module level connection dictionary

    :param str dsn_hash: Hash generated by _generate_connection
    :param psycopg2._psycopg.connection connection: PostgreSQL connection
    :returns bool: Connection was cached or was already cached

    """
    global CONNECTIONS
    if dsn_hash not in CONNECTIONS:
        CONNECTIONS[dsn_hash] = {CLIENTS: 1, HANDLE: connection, LAST: 0}
        LOGGER.info('%s: added to module pool', dsn_hash)
        return True
    return False


def _check_for_unused_expired_connections():
    """Check the module level connection cache for connections without any
    clients and remove them if the TTL has passed.

    """
    global CONNECTIONS
    for dsn_hash in CONNECTIONS.keys():
        if (not CONNECTIONS[dsn_hash][CLIENTS] and
            (time.time() > CONNECTIONS[dsn_hash][LAST] + CACHE_TTL)):
            LOGGER.info('Removing expired connection: %s', dsn_hash)
            del CONNECTIONS[dsn_hash]


def _generate_connection_hash(dsn):
    """Generates a connection hash for the given parameters.

    :param str dsn: DSN for connection
    :rtype: str

    """
    return str(hashlib.sha1(dsn).hexdigest())


def _get_cached_connection(dsn_hash):
    """Check our global connection stack to see if we already have a
    connection with the same exact connection parameters and use it if so.

    :param str dsn_hash: Hash generated by _generate_connection_hash
    :rtype: psycopg2._psycopg.connection or None

    """
    _check_for_unused_expired_connections()
    if dsn_hash in CONNECTIONS:
        LOGGER.debug('Returning cached connection and incrementing counter')
        CONNECTIONS[dsn_hash][CLIENTS] += 1
        return CONNECTIONS[dsn_hash][HANDLE]
    return None


def _free_cached_connection(dsn_hash):
    """Decrement our use counter for the hash and if it is the only one, delete
    the cached connection.

    :param str dsn_hash: Hash generated by _generate_connection_hash

    """
    global CONNECTIONS
    if dsn_hash in CONNECTIONS:
        LOGGER.debug('%s: decrementing client count', dsn_hash)
        CONNECTIONS[dsn_hash][CLIENTS] -= 1
        if not CONNECTIONS[dsn_hash][CLIENTS]:
            LOGGER.debug('%s: updating last client time', dsn_hash)
            CONNECTIONS[dsn_hash][LAST] = int(time.time())


class PgSQL(object):
    """PostgreSQL connection object.

    Uses a module level cache of connections to reduce overhead.

    """
    def __init__(self,
                 host='localhost',
                 port=5432,
                 dbname=None,
                 user='www',
                 password=None,
                 cursor_factory=extras.RealDictCursor):
        """Connect to a PostgreSQL server using the module wide connection and
        set the isolation level.

        :param str host: Host to connect to
        :param int port: Port to connect on
        :param str dbname: The database name
        :param str user: User to connect as
        :param str password: The password to use, None for no password
        :param psycopg2.cursor: The cursor type to use

        """
        self._conn = self._get_connection(host, port, dbname, user, password)
        self._autocommit()
        self._dsn_hash = None
        self._cursor = self._get_cursor(cursor_factory)
        self._register_unicode()
        self._register_uuid()

    def __del__(self):
        """Remove our connection from the stack when we're done."""
        if self._dsn_hash:
            _free_cached_connection(self._dsn_hash)

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self._dsn_hash:
            _free_cached_connection(self._dsn_hash)

    @property
    def connection(self):
        """Returns the psycopg2 PostgreSQL connection instance

        :rtype: psycopg2.connection

        """
        return self._conn

    @property
    def cursor(self):
        """Returns the cursor instance

        :rtype: psycopg2._psycopg.cursor

        """
        return self._cursor

    def _add_connection_to_cache(self):
        """Add the connection to the module wide connection pool.

        :param psycopg2.connection: The new connection

        """
        _add_cached_connection(self._dsn_hash, self._conn)

    def _autocommit(self):
        """Set the isolation level automatically to commit after every query

        :param psycopg2.connection connection: Connection to set level on

        """
        self._conn.set_isolation_level(extensions.ISOLATION_LEVEL_AUTOCOMMIT)

    @staticmethod
    def _connect(dsn):
        """Connect to PostgreSQL using the DSN.

        :param str dsn: The connection dsn
        :rtype: psycopg2.connection

        """
        LOGGER.info('Connecting to %s', dsn)
        return psycopg2.connect(dsn)

    def _get_connection(self, host, port, dbname, user, password):
        """Return a connection, cached or otherwise for the given DSN.

        :param str host: Host to connect to
        :param int port: Port to connect on
        :param str dbname: The database name
        :param str user: User to connect as
        :param str password: The password to use, None for no password
        :rtype: psycopg2.connection

        """
        dsn = self._get_dsn(host, port, dbname, user, password)

        # Generate a connection hash for module level instance of connection
        self._connection_hash = _generate_connection_hash(dsn)

        # Attempt to get a cached connection from our module level pool
        connection = _get_cached_connection(self._connection_hash)

        # If we got a result, just log our success in doing so
        if connection:
            LOGGER.debug("%s: reusing cached connection",
                         self._connection_hash)
            return connection

        # Create a new PostgreSQL connection and cache it
        connection = self._connect(dsn)

        # Cache the connection
        self._add_connection_to_cache()

        # Added in because psycopg2ct connects and leaves the connection in
        # a weird state: consts.STATUS_DATESTYLE, returning from
        # Connection._setup without setting the state as const.STATUS_OK
        if PYPY:
            connection.reset()

        # Return the connection
        return connection

    def _get_cursor(self, cursor_factory):
        """Return a cursor for the given cursor_factory.

        :param psycopg2.cursor: The cursor type to use
        :rtype: psycopg2.extensions.cursor

        """
        return self._conn.cursor(cursor_factory=cursor_factory)

    @staticmethod
    def _get_dsn(host, port, dbname, user, password):
        """Create a DSN for the specified attributes.

        :param str host: Host to connect to
        :param int port: Port to connect on
        :param str dbname: The database name
        :param str user: User to connect as
        :param str password: The password to use, None for no password
        :return str: The DSN to connect

        """
        dsn = "host='%s' port=%i dbname='%s' user='%s'" % (host,
                                                           port,
                                                           dbname,
                                                           user)
        # Add the password if specified
        if password:
            dsn += " password='%s'" % password

        return dsn

    def _register_unicode(self):
        """Register the cursor to be able to receive Unicode string.

        :param psycopg2.cursor: The cursor to add unicode support to

        """
        psycopg2.extensions.register_type(psycopg2.extensions.UNICODE,
                                          self._cursor)
        psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY,
                                          self._cursor)

    def _register_uuid(self):
        """Register the UUID extension from psycopg2"""
        psycopg2.extras.register_uuid(self._conn)

