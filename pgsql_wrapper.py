"""PostgreSQL Class module

An opinionated wrapper for interfacing with PostgreSQL that offers caching of
connections and support for PyPy via psycopg2ct. By default the PgSQL class
sets the cursor type to extras.DictCursor, and turns on both Unicode and UUID
support.

"""
__version__ = '1.2.0'

import hashlib
import logging
import platform
import time

# Import PyPy compatibility
PYPY = False
target = platform.python_implementation()
if target == 'PyPy':
    from psycopg2ct import compat
    compat.register()
    PYPY = True

# Import psycopg2 and it's extensions and extras
import psycopg2
from psycopg2 import extensions
from psycopg2 import extras

# Expose exceptions so clients do not need to import psycopg2 too
from psycopg2 import DataError
from psycopg2 import DatabaseError
from psycopg2 import IntegrityError
from psycopg2 import InterfaceError
from psycopg2 import InternalError
from psycopg2 import NotSupportedError
from psycopg2 import OperationalError
from psycopg2 import ProgrammingError
from psycopg2.extensions import QueryCanceledError
from psycopg2.extensions import TransactionRollbackError

LOGGER = logging.getLogger(__name__)

# Defaults
DEFAULT_HOST = 'localhost'
DEFAULT_PORT = 5432
DEFAULT_DBNAME = 'postgres'
DEFAULT_USER = 'postgres'
DEFAULT_PASSWORD = ''

# Connection caching constants
CACHE_TTL = 60
CLIENTS = 'clients'
HANDLE = 'handle'
LAST = 'last_client'
CONNECTIONS = dict()


def _add_cached_connection(dsn_hash, connection):
    """Add the connection to our module level connection dictionary

    :param str dsn_hash: Hash generated by _generate_connection
    :param psycopg2._psycopg.connection connection: PostgreSQL connection
    :returns bool: Connection was cached or was already cached

    """
    global CONNECTIONS
    if dsn_hash not in CONNECTIONS:
        CONNECTIONS[dsn_hash] = {CLIENTS: 1, HANDLE: connection, LAST: 0}
        LOGGER.info('%s: added to module pool', dsn_hash)
        return True
    return False


def _check_for_unused_expired_connections():
    """Check the module level connection cache for connections without any
    clients and remove them if the TTL has passed.

    """
    global CONNECTIONS
    for dsn_hash in list(CONNECTIONS.keys()):
        if (not CONNECTIONS[dsn_hash][CLIENTS] and
            (time.time() > CONNECTIONS[dsn_hash][LAST] + CACHE_TTL)):
            LOGGER.info('Removing expired connection: %s', dsn_hash)
            del CONNECTIONS[dsn_hash]


def _generate_connection_hash(dsn):
    """Generates a connection hash for the given parameters.

    :param str dsn: DSN for connection
    :rtype: str

    """
    return str(hashlib.sha1(dsn.encode('utf-8')).hexdigest())


def _get_cached_connection(dsn_hash):
    """Check our global connection stack to see if we already have a
    connection with the same exact connection parameters and use it if so.

    :param str dsn_hash: Hash generated by _generate_connection_hash
    :rtype: psycopg2._psycopg.connection or None

    """
    _check_for_unused_expired_connections()
    if dsn_hash in CONNECTIONS:
        LOGGER.debug('Returning cached connection and incrementing counter')
        CONNECTIONS[dsn_hash][CLIENTS] += 1
        return CONNECTIONS[dsn_hash][HANDLE]
    return None


def _free_cached_connection(dsn_hash):
    """Decrement our use counter for the hash and if it is the only one, delete
    the cached connection.

    :param str dsn_hash: Hash generated by _generate_connection_hash

    """
    global CONNECTIONS
    if dsn_hash in CONNECTIONS:
        LOGGER.debug('%s: decrementing client count', dsn_hash)
        CONNECTIONS[dsn_hash][CLIENTS] -= 1
        if not CONNECTIONS[dsn_hash][CLIENTS]:
            LOGGER.debug('%s: updating last client time', dsn_hash)
            CONNECTIONS[dsn_hash][LAST] = int(time.time())


def _remove_cached_connection(dsn_hash):
    """Remove the cached connection, explicitly closing it.

    :param str dsn_hash: Hash generated by _generate_connection_hash

    """
    global CONNECTIONS
    if dsn_hash in CONNECTIONS:
        LOGGER.debug('%s: decrementing client count', dsn_hash)
        del CONNECTIONS[dsn_hash]


class PgSQL(object):
    """PostgreSQL connection object.

    Uses a module level cache of connections to reduce overhead.

    """
    def __init__(self,
                 host=DEFAULT_HOST,
                 port=DEFAULT_PORT,
                 dbname=DEFAULT_DBNAME,
                 user=DEFAULT_USER,
                 password=DEFAULT_PASSWORD,
                 cursor_factory=extras.RealDictCursor):
        """Connect to a PostgreSQL server using the module wide connection and
        set the isolation level.

        :param str host: Host to connect to
        :param int port: Port to connect on
        :param str dbname: The database name
        :param str user: User to connect as
        :param str password: The password to use, None for no password
        :param psycopg2.cursor: The cursor type to use

        """
        self._dsn = None
        self._dsn_hash = None
        self._cached_connection = False
        self._conn = None
        self._connect(host, port, dbname, user, password)
        self._cursor = self._get_cursor(cursor_factory)
        self._autocommit()
        # Don't re-register unicode or uuid
        if not self._cached_connection:
            self._register_unicode()
            self._register_uuid()

    def __del__(self):
        """When deleting the context, ensure the instance is removed from
        caches, etc.

        """
        self._cleanup()

    def __enter__(self):
        """For use as a context manager, return a handle to this object
        instance.

        :rtype: PgSQL

        """
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """When leaving the context, ensure the instance is removed from
        caches, etc.

        """
        self._cleanup()

    def close(self):
        """Explicitly close the connection and remove it from the connection
        cache.

        :raises: AssertionError

        """
        if not self._conn:
            raise AssertionError('Connection not open')
        self._conn.close()
        _remove_cached_connection(self._dsn_hash)
        self._conn = None
        self._cursor = None

    @property
    def connection(self):
        """Returns the psycopg2 PostgreSQL connection instance

        :rtype: psycopg2.connection

        """
        return self._conn

    @property
    def cursor(self):
        """Returns the cursor instance

        :rtype: psycopg2._psycopg.cursor

        """
        return self._cursor

    def _add_connection_to_cache(self):
        """Add the connection to the module wide connection pool.

        :param psycopg2.connection: The new connection

        """
        _add_cached_connection(self._dsn_hash, self._conn)

    def _autocommit(self):
        """Set the isolation level automatically to commit after every query"""
        self._conn.autocommit = True

    def _cleanup(self):
        """Remove the connection from the stack, closing out the cursor"""
        if self._cursor:
            self._cursor.close()
            self._cursor = None
        if self._conn:
            _free_cached_connection(self._dsn_hash)
            self._conn = None

    def _connect(self, host, port, dbname, user, password):
        """Return a connection, cached or otherwise for the given DSN.

        :param str host: Host to connect to
        :param int port: Port to connect on
        :param str dbname: The database name
        :param str user: User to connect as
        :param str password: The password to use, None for no password

        """
        self._dsn = self._get_dsn(host, port, dbname, user, password)

        # Generate a connection hash for module level instance of connection
        self._dsn_hash = _generate_connection_hash(self._dsn)

        # Attempt to get a cached connection from our module level pool
        self._conn = _get_cached_connection(self._dsn_hash)

        # If we got a result, just log our success in doing so
        if not self._conn:

            # Create a new PostgreSQL connection and cache it
            LOGGER.info('%s: connecting to %s', self._dsn_hash, self._dsn)
            self._conn = psycopg2.connect(self._dsn)

            # Cache the connection
            self._add_connection_to_cache()

            # Added in because psycopg2ct connects and leaves the connection in
            # a weird state: consts.STATUS_DATESTYLE, returning from
            # Connection._setup without setting the state as const.STATUS_OK
            if PYPY:
                self._conn.reset()
        else:
            LOGGER.debug("%s: reusing cached connection", self._dsn_hash)
            self._cached_connection = True

    def _get_cursor(self, cursor_factory):
        """Return a cursor for the given cursor_factory.

        :param psycopg2.cursor: The cursor type to use
        :rtype: psycopg2.extensions.cursor

        """
        return self._conn.cursor(cursor_factory=cursor_factory)

    @staticmethod
    def _get_dsn(host, port, dbname, user, password):
        """Create a DSN for the specified attributes.

        :param str host: Host to connect to
        :param int port: Port to connect on
        :param str dbname: The database name
        :param str user: User to connect as
        :param str password: The password to use, None for no password
        :return str: The DSN to connect

        """
        dsn = "host='%s' port=%i dbname='%s' user='%s'" % (host,
                                                           port,
                                                           dbname,
                                                           user)
        # Add the password if specified
        if password:
            dsn += " password='%s'" % password

        return dsn

    def _register_unicode(self):
        """Register the cursor to be able to receive Unicode string.

        :param psycopg2.cursor: The cursor to add unicode support to

        """
        psycopg2.extensions.register_type(psycopg2.extensions.UNICODE,
                                          self._cursor)
        psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY,
                                          self._cursor)

    def _register_uuid(self):
        """Register the UUID extension from psycopg2"""
        psycopg2.extras.register_uuid(self._conn)
